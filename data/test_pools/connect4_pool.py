# -*- coding: utf-8 -*-
"""connect4_pool.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kIa6WblnVVB2xtStZErv-0Vtzvy14Us1
"""
import json
import random
import numpy as np
from pathlib import Path
from envs.connect4 import C4

# ---------------- Utilities ----------------

def _stones_filled(g: C4) -> int:
    return int(np.count_nonzero(g.board))

def _roll_selfplay_to_plies(low, high):
    g = C4()
    for _ in range(random.randint(low, high)):
        if g.done:
            break
        ls = g.legal_actions()
        if not ls:
            break
        g.step(random.choice(ls))
    return g

def _extract_from_episode(moves, max_take, ply_low=None, ply_high=None):
    """
    Reconstruct intermediate states from one episode.
    """
    out = []
    g = C4()
    for ply, a in enumerate(moves):
        if g.done:
            break
        g.step(int(a))
        take = True
        if ply_low is not None and ply < ply_low:
            take = False
        if ply_high is not None and ply > ply_high:
            take = False
        if take:
            out.append(g.clone())
        if len(out) >= max_take:
            break
    return out

# ---------------- Main pool builder ----------------

def build_pool_stratified(
    max_samples=5000,
    ratio=(1/3, 1/3, 1/3),
    episodes_file=None,
    seed=42,
):
    """
    Build a stratified Connect-4 test pool.

    Priority:
    1) Episode-derived states (MuZero self-play)
    2) Random self-play fallback
    """
    random.seed(seed)
    pool = []

    early_q, mid_q, late_q = ratio
    nE = int(max_samples * early_q)
    nM = int(max_samples * mid_q)
    nL = max_samples - nE - nM

    early, mid, late = [], [], []

    # -------- 1) Episode-derived states --------
    if episodes_file is not None and Path(episodes_file).exists():
        with open(episodes_file, "r") as f:
            for line in f:
                try:
                    rec = json.loads(line)
                    moves = rec.get("moves") or rec.get("actions")
                    if not moves:
                        continue

                    # Early: 0–10 plies
                    early.extend(_extract_from_episode(
                        moves, max_take=10, ply_low=0, ply_high=10
                    ))

                    # Mid: 11–24 plies
                    mid.extend(_extract_from_episode(
                        moves, max_take=10, ply_low=11, ply_high=24
                    ))

                    # Late: near-terminal
                    g = C4()
                    for a in moves:
                        if g.done:
                            break
                        g.step(int(a))
                    if _stones_filled(g) >= 32:
                        late.append(g.clone())

                except Exception:
                    continue

                if len(early) >= nE and len(mid) >= nM and len(late) >= nL:
                    break

    # -------- 2) Random fallback --------
    while len(early) < nE:
        early.append(_roll_selfplay_to_plies(0, 10))

    while len(mid) < nM:
        mid.append(_roll_selfplay_to_plies(11, 24))

    while len(late) < nL:
        g = _roll_selfplay_to_plies(26, 42)
        if _stones_filled(g) >= 32:
            late.append(g)

    # -------- Finalize --------
    pool = early[:nE] + mid[:nM] + late[:nL]
    random.shuffle(pool)

    return pool